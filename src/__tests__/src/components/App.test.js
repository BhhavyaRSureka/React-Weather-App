// ********RoostGPT********
// Test generated by RoostGPT for test ReactTesting using AI Type Open AI and AI Model gpt-4-1106-preview



// ********RoostGPT********
import React from 'react';
import { render, fireEvent, waitFor } from '@testing-library/react';
import axios from 'axios';
import App from '../../../components/App.js'; // Adjusted the path to account for the location of the test file

// Mock axios to prevent actual HTTP requests
jest.mock('axios');

describe('App component', () => {
  test('renders without crashing', () => {
    const { getByText } = render(<App />);
    expect(getByText(/Searching../i)).toBeInTheDocument();
  });

  test('contains the SearchEngine component', () => {
    const { getByPlaceholderText } = render(<App />);
    expect(getByPlaceholderText(/Enter city name/i)).toBeInTheDocument();
  });

  test('conditionally renders the Forecast component', async () => {
    axios.get.mockResolvedValueOnce({
      data: {
        condition: {},
      },
    });
    const { getByText } = render(<App />);
    await waitFor(() => getByText(/Monday/i)); // Assuming Monday is part of the conditionally rendered component
    expect(getByText(/Monday/i)).toBeInTheDocument();
  });

  test('search function fetches weather data successfully', async () => {
    const weatherData = { condition: {} };
    axios.get.mockResolvedValueOnce({ data: weatherData });

    const { getByText, getByPlaceholderText } = render(<App />);
    fireEvent.change(getByPlaceholderText(/Enter city name/i), { target: { value: 'Berlin' } });
    fireEvent.keyDown(getByPlaceholderText(/Enter city name/i), { key: 'Enter' });

    await waitFor(() => expect(getByText(/Monday/i)).toBeInTheDocument());
    expect(axios.get).toHaveBeenCalledTimes(1);
  });

  test('displays error message when fetch fails', async () => {
    axios.get.mockRejectedValueOnce(new Error('City not found'));

    const { getByText, getByPlaceholderText } = render(<App />);
    fireEvent.change(getByPlaceholderText(/Enter city name/i), { target: { value: 'Unknown' } });
    fireEvent.keyDown(getByPlaceholderText(/Enter city name/i), { key: 'Enter' });

    await waitFor(() => expect(getByText(/Sorry city not found, please try again./i)).toBeInTheDocument());
  });
});

